
### JHVH-4x4

> So I had thought for some time on the programming language to end all programming languages. 
> 
> Right now most (good) programming languages are fairly low level. An analogy might be describing all the intricate steps to laying a brick wall (amount of mortar, mix of the mortar, spacing of the bricks, prep work to start laying, clean up process after laying, etc.) if you are lucky there is a library function to handle some of this but you will need to understand and implement the syntax. At this point you can easily screw things up and will have to look for something stupid like using a colon instead of a semi-colon or any of number of other problems. All of this can be avoided if you can describe what you want to do and then allow an AI interpreter to do it. The syntax is irrelevant if the interpreter understands what you want. Essentially, this would require a real-time, interpreter/compiler. As you write the software the results are presented. 
> 
> Example: User: Add two valuesAI: Describe Value one, Value twoUser: Blah & BlahAI: Function may produce unusable results, suggest adding additional bounding, see here.

> The result is an unbounded language that can have a virtually limitless number of functions or macros. If you wanted a language that was a combination of lisp, small talk and C with your own commands thrown in that would be fine. As long as the interpreter knows what's going on it's fine. Like when twins create their own language. 
> 
> Of course the question/concern is won't thins make a tower of Babel? No, not necessarily. The AI/Interpreter understands the source and the resulting code. The AI/I could easily take the Human readable source or rather meta-code and convert it to machine readable meta-code. The MRMC is stamped with a version representing a machine generated glossary. MRMC is a description of the function of the code. The function map can then be translated into any language the user desires along with any comments (either human or machine generated) included.

### Upgrade

> Yes, the hubristic user interface for programming looks viable now or soon:https://www.unqualified-reservations.org/2009/07/wolfram-alpha-and-hubristic-user/
> 
> But this is not actually the problem really -- it comes from a misconception that non-programmers have about what programmers do.
> 
> The ability to read and write Spanish proficiently will not make you Cervantes.
> 
> The real problem is that non-programmers think in ways that are too vague, imprecise, and unsystematic for building complex systems, and natural language is unsuitable for describing anything sufficiently unambiguously.
> 
> 
> "take the Human readable source or rather meta-code and convert it to machine readable meta-code"
> 
> Yes, we call that a compiler. The main point of high level programming languages is that they are the human readable version of a computer program.

> Taking it from another angle -- I suspect a big part of our trouble now is that we should be expressing much much more about the structure and behavior of our software visually with graphs and diagrams instead of purely with language only. Related to this we need to be able to organize things in ways that let us see the big picture of the thing we are working on, but also drill into details without getting bogged down because the details we need are tangled up with the details we don't.
> 
> Language models can help us offload a lot of work to the machines that we couldn't before, but we still need to be able to structure software in a way that it can be subdivided into right size chunks humans can talk about and think about without breaking stuff in adjacent (or distant!) parts of the system
> 
> Ideally coming out of this much of the system would be very much like you are imagining. Humans would be working against basically English language documentation of the system, maybe even using a UI that resembles Ted Nelson's stuff in some ways, but also through speech instead of screens when we like. The machines can help us with the task of keeping English overview synchronized (both ways) with the actual code, but until we have full Strong AI we'll still need humans to be able to work with more precise tools sometimes than English. Again though, that doesn't necessarily have to be programming languages as we know them. It could look more like Scratch, or Touch Designer.
> 
> But yes I think you are generally on track with this. We may even be able to get the language model chatbots trained up to ask the right questions much of the time, and in natural language, to guide a person to consider the right information to make the right decisions, and to resolve the inconsistencies and imprecision in what they are trying to ask for


> One of the funny things with Ted Nelson is that he really sees so well how all of this went off track at Xerox PARC. All of our systems are built on a user interface system that was all about paper metaphor thinking and paper compatibility. It's great for selling printers and copy machines. But being so anti-PARC I think means that he misses a lot of the things that were really cool about what they did at PARC. Much of the really important really valuable stuff there got lost as we went from the Alto to the Macintosh and Windows and all the variations we see in the Linux desktop.
> 
> If he had been building his system the way that they built Smalltalk, I think he might have had more success with it by now.
